# Full eMMC Clone & Flash Over Ethernet (SSH)
### Embedded Linux — Live System — No Vendor Tools Required
---

## Mission Brief

You've got an embedded Linux box running on eMMC. Maybe it's an industrial controller, a custom board, or some IoT device buried in a cabinet somewhere. You need to clone it, back it up, or flash a fresh image—but you can't physically touch it. No SD card slots. No USB access. Just network and SSH.

This is how you do it.

---

## What You're Working With

```
Target Hardware:
├─ eMMC storage (not removable)
├─ Ethernet port (your only lifeline)
├─ SSH access (preferably root)
└─ Hopefully stable power

Main Device: /dev/mmcblk2
├─ /dev/mmcblk2p1 (boot)
├─ /dev/mmcblk2p2 (rootfs)
├─ /dev/mmcblk2boot0 (bootloader)
└─ /dev/mmcblk2boot1 (bootloader backup)
```

**The Rules:**
- Target eMMC ≥ Source eMMC (always)
- Same hardware platform (don't flash i.MX6 images to Rockchip boards)
- Stable power supply (UPS, battery backup, whatever it takes)
- Root SSH access verified before you start

---

## Part I: Full System Clone (1:1 Bit-Perfect Copy)

### When You Need This
- Migrating from one device to an identical device
- Creating forensic-level backups
- Hardware replacement in the field
- "Just make it exactly the same" scenarios

---

### Step 1: Pull Everything Off the Source Device

Open a terminal. You're going to pull the entire eMMC over the network.

```bash
# Full disk image (gzip compressed)
ssh root@192.168.1.100 "dd if=/dev/mmcblk2 bs=4M status=progress" \
  | gzip -9 > mmcblk2_full_$(date +%Y%m%d).img.gz
```

**Better version with Zstandard** (faster, smaller, multi-threaded):
```bash
ssh root@192.168.1.100 "dd if=/dev/mmcblk2 bs=4M status=progress" \
  | zstd -T0 -19 > mmcblk2_full_$(date +%Y%m%d).img.zst
```

Now grab the boot partitions:
```bash
ssh root@192.168.1.100 "dd if=/dev/mmcblk2boot0 bs=1M" > boot0_$(date +%Y%m%d).img
ssh root@192.168.1.100 "dd if=/dev/mmcblk2boot1 bs=1M" > boot1_$(date +%Y%m%d).img
```

**What just happened:**
- `dd` reads raw blocks from eMMC
- Piped over SSH to your local machine
- Compressed on-the-fly to save disk space
- You now have a complete snapshot

**Pro tip:** Label these files properly. Trust me. Six months from now you won't remember which backup is which.

---

### Step 2: Push to Target Device

You've got the image. Now write it to the new device.

**THIS WILL NUKE EVERYTHING ON THE TARGET**

```bash
# Decompress and write directly
zstd -dc mmcblk2_full_20260120.img.zst \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2 bs=4M status=progress && sync"
```

If you used gzip:
```bash
gunzip -c mmcblk2_full_20260120.img.gz \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2 bs=4M status=progress && sync"
```

**Watch the output.** You'll see transfer progress. Don't interrupt it. Don't power cycle. Just wait.

---

### Step 3: Deal With Boot Partitions

eMMC boot partitions are write-protected by default. Linux does this to prevent accidental bootloader corruption. You need to unlock them first.

```bash
# On target device, unlock boot partitions
ssh root@192.168.1.101 "
echo 0 > /sys/block/mmcblk2boot0/force_ro
echo 0 > /sys/block/mmcblk2boot1/force_ro
"
```

Verify they're writable:
```bash
ssh root@192.168.1.101 "cat /sys/block/mmcblk2boot0/force_ro"
# Should return: 0
```

Now flash the bootloaders:
```bash
cat boot0_20260120.img \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2boot0 bs=1M status=progress"

cat boot1_20260120.img \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2boot1 bs=1M status=progress"
```

Flush everything to disk:
```bash
ssh root@192.168.1.101 "sync"
```

Lock them back down:
```bash
ssh root@192.168.1.101 "
echo 1 > /sys/block/mmcblk2boot0/force_ro
echo 1 > /sys/block/mmcblk2boot1/force_ro
"
```

---

### Step 4: Reboot and Verify

```bash
ssh root@192.168.1.101 "reboot"
```

Wait 60-90 seconds. Try to reconnect:
```bash
ssh root@192.168.1.101 "uname -a && df -h && uptime"
```

If it boots, you're done. If it doesn't... well, that's why we test this stuff first.

---

### Step 5: Post-Clone Cleanup

Your cloned device has identical identifiers to the source. Fix that:

```bash
ssh root@192.168.1.101 "
# Remove machine ID (systemd will regenerate on next boot)
rm -f /etc/machine-id
systemd-machine-id-setup

# Remove persistent network rules (may cause MAC conflicts)
rm -f /etc/udev/rules.d/70-persistent-net.rules

# Change hostname
hostnamectl set-hostname device-clone-01

# Reboot to apply
reboot
"
```

---

## Part II: Flashing Fresh Images (WIC/OS Images)

### When You Need This
- Deploying new builds from your CI/CD pipeline
- Factory provisioning
- Firmware updates in the field
- "Burn this image to that device" scenarios

---

### The Image File

You've got a file like: `img-full.rootfs.wic.zst`

This is a complete disk image. Bootloader, kernel, rootfs, partition table—everything. Usually generated by Yocto, Buildroot, or similar build systems.

**Verify it first:**
```bash
# Check integrity
zstd -t img-full.rootfs.wic.zst

# Check size
zstd -l img-full.rootfs.wic.zst
```

Output:
```
Compressed Size:   1.2 GB
Decompressed Size: 7.3 GB
Ratio:             6.08
```

Make sure your target eMMC is ≥ 7.3 GB. Check with:
```bash
ssh root@192.168.1.101 "lsblk | grep mmcblk"
```

---

### Flash It

**Method 1: Direct Streaming (Fast, Network-Dependent)**

```bash
zstd -dc img-full.rootfs.wic.zst \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2 bs=4M status=progress && sync"
```

**What's happening:**
- `zstd -dc` decompresses to stdout
- Pipes over SSH
- `dd` writes raw data to eMMC
- `sync` ensures everything hits the disk

**Method 2: Transfer Then Flash (Safer, Network-Independent)**

If your network is flaky or you don't trust the connection:

```bash
# Step 1: Copy compressed file to device
scp img-full.rootfs.wic.zst root@192.168.1.101:/tmp/

# Step 2: Flash on device
ssh root@192.168.1.101 "
cd /tmp
zstd -dc img-full.rootfs.wic.zst | dd of=/dev/mmcblk2 bs=4M status=progress
sync
rm img-full.rootfs.wic.zst
"
```

**Trade-off:** Uses device storage temporarily, but safer if network drops.

---

### Monitor Progress (Optional but Useful)

Install `pv` (pipe viewer) for progress bars:

```bash
sudo apt install pv

# Use it like this:
zstd -dc img-full.rootfs.wic.zst | pv \
  | ssh root@192.168.1.101 "dd of=/dev/mmcblk2 bs=4M && sync"
```

Output:
```
1.2GiB 0:05:23 [3.8MiB/s] [==============>      ] 65% ETA 0:02:47
```

---

### Reboot

```bash
ssh root@192.168.1.101 "reboot"
```

Wait. Try to reconnect. If it boots, you're golden.

---

### Post-Flash Tasks

**Expand filesystem** (if your eMMC is bigger than the image):

```bash
# Resize partition
ssh root@192.168.1.101 "growpart /dev/mmcblk2 2"

# Resize filesystem
ssh root@192.168.1.101 "resize2fs /dev/mmcblk2p2"

# Verify
ssh root@192.168.1.101 "df -h /"
```

**Set unique identifiers:**
```bash
ssh root@192.168.1.101 "
rm -f /etc/machine-id
systemd-machine-id-setup
hostnamectl set-hostname production-unit-042
"
```

---

## Part III: Advanced Techniques

### Handling Different Compression Formats

**You might encounter:**
- `.img.gz` (gzip - old standard)
- `.img.zst` (zstandard - modern, faster)
- `.img.xz` (xz - high compression, slow)
- `.img.bz2` (bzip2 - outdated)

**How to flash each:**

```bash
# gzip
gunzip -c image.img.gz \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

# zstandard (recommended)
zstd -dc image.img.zst \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

# xz
xz -dc image.img.xz \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

# bzip2
bzcat image.img.bz2 \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"
```

---

### Compression Comparison

Real-world test on 7.3 GB eMMC image:

| Format | Size | Compression Time | Decompression Speed | Network Transfer |
|--------|------|-----------------|---------------------|-----------------|
| Uncompressed | 7.3 GB | - | - | ~15 min (100 Mbps) |
| gzip -9 | 2.1 GB | ~12 min | ~300 MB/s | ~4 min |
| zstd -19 | 1.8 GB | ~8 min | ~900 MB/s | ~3.5 min |
| xz -9 | 1.5 GB | ~45 min | ~100 MB/s | ~3 min |

**Verdict:** Use Zstandard. Best balance of size and speed.

---

### Creating Your Own Zstandard Backups

```bash
# Fast backup (level 3, good for testing)
ssh root@DEVICE "dd if=/dev/mmcblk2 bs=4M" \
  | zstd -T0 -3 > backup_fast_$(date +%Y%m%d).img.zst

# Maximum compression (level 19, archival)
ssh root@DEVICE "dd if=/dev/mmcblk2 bs=4M" \
  | zstd -T0 -19 > backup_archive_$(date +%Y%m%d).img.zst

# Balanced (default level, recommended)
ssh root@DEVICE "dd if=/dev/mmcblk2 bs=4M" \
  | zstd -T0 > backup_$(date +%Y%m%d).img.zst
```

**Flags explained:**
- `-T0` = use all CPU cores
- `-3` / `-19` = compression level (1=fast, 19=max)
- Default is level 3

---

### Dealing With Flaky Networks

If your SSH connection keeps dropping:

**Option 1: Use screen/tmux on the device**

```bash
# Start screen session on device
ssh root@DEVICE
screen -S flash

# Run flash command inside screen
zstd -dc /tmp/image.wic.zst | dd of=/dev/mmcblk2 bs=4M status=progress
sync

# Detach: Ctrl+A, then D
# Your connection can drop now, flash continues

# Reconnect later
ssh root@DEVICE
screen -r flash
```

**Option 2: Use nohup**

```bash
# Transfer file first
scp image.wic.zst root@DEVICE:/tmp/

# Run flash in background, survives disconnects
ssh root@DEVICE "
nohup sh -c 'zstd -dc /tmp/image.wic.zst | dd of=/dev/mmcblk2 bs=4M > /tmp/flash.log 2>&1 && sync' &
"

# Monitor progress
ssh root@DEVICE "tail -f /tmp/flash.log"
```

---

### Flashing Individual Components

Sometimes you don't need the whole image. Just kernel or rootfs.

**Flash only kernel:**
```bash
# If kernel is in boot partition
zstd -dc zImage.zst \
  | ssh root@DEVICE "dd of=/dev/mmcblk2p1 bs=1M status=progress && sync"

# Or replace in /boot directory
scp zImage root@DEVICE:/boot/
ssh root@DEVICE "sync && reboot"
```

**Flash only rootfs (ext4 image):**
```bash
zstd -dc rootfs.ext4.zst \
  | ssh root@DEVICE "dd of=/dev/mmcblk2p2 bs=4M status=progress && sync"
```

**Extract rootfs tarball:**
```bash
# Mount partition first
ssh root@DEVICE "mount /dev/mmcblk2p2 /mnt"

# Extract over SSH
zstd -dc rootfs.tar.zst \
  | ssh root@DEVICE "tar -xf - -C /mnt"

# Sync and unmount
ssh root@DEVICE "sync && umount /mnt && reboot"
```

**Flash bootloader only:**
```bash
# Unlock boot partition
ssh root@DEVICE "echo 0 > /sys/block/mmcblk2boot0/force_ro"

# Flash u-boot (offset may vary by platform)
cat u-boot.imx \
  | ssh root@DEVICE "dd of=/dev/mmcblk2boot0 bs=1K seek=1 && sync"

# Lock it back
ssh root@DEVICE "echo 1 > /sys/block/mmcblk2boot0/force_ro"
```

---

## Part IV: When Things Go Wrong

### Device Won't Boot After Flash

**Check list:**
1. Did the flash complete? Check logs.
2. Is the image compatible with your hardware?
3. Did you flash the correct device (`mmcblk0` vs `mmcblk2`)?
4. Was power stable during the entire operation?
5. Did you flash boot partitions if needed?

**Recovery options:**

**Option A: Boot from SD card**
- Insert SD card with recovery image
- Boot from SD
- Reflash eMMC from there

**Option B: Use serial console**
- Connect UART/serial cable
- Access U-Boot
- Reflash via TFTP or USB

**Option C: Hardware recovery mode**
- Check board documentation
- Most SoCs have a hardware recovery mode (eMMC boot disabled)
- Allows USB flashing via vendor tools

---

### "Operation not permitted" on boot partitions

**Cause:** Boot partitions are write-protected.

**Fix:**
```bash
ssh root@DEVICE "
echo 0 > /sys/block/mmcblk2boot0/force_ro
echo 0 > /sys/block/mmcblk2boot1/force_ro
"
```

**Verify:**
```bash
ssh root@DEVICE "cat /sys/block/mmcblk2boot*/force_ro"
# Both should return: 0
```

---

### "No space left on device"

**Cause:** Target eMMC is smaller than image.

**Check sizes:**
```bash
# Image size (decompressed)
zstd -l image.wic.zst

# Device size
ssh root@DEVICE "blockdev --getsize64 /dev/mmcblk2"
```

**Solutions:**
- Use a smaller image
- Get a device with larger eMMC
- Manually partition and copy filesystem (advanced, not recommended)

---

### "Device or resource busy"

**Cause:** Trying to write to mounted filesystem.

**Check what's mounted:**
```bash
ssh root@DEVICE "mount | grep mmcblk2"
```

**Try to unmount:**
```bash
ssh root@DEVICE "umount /dev/mmcblk2p1 /dev/mmcblk2p2"
```

**If that fails:**
- Boot from alternative media (SD card, NFS, initramfs)
- Use recovery mode
- Accept that you can't flash a running system's root partition (common limitation)

---

### SSH connection drops mid-flash

**Prevention:**
- Use `screen` or `tmux` on device
- Use `nohup` with background process
- Transfer file first, then flash locally

**If it already happened:**
- Check if process is still running: `ssh root@DEVICE "ps aux | grep dd"`
- If running, let it finish
- If not, start over (partial flashes are bad)

---

### Wrong device flashed

**Prevention:**
```bash
# ALWAYS verify device first
ssh root@DEVICE "lsblk"
ssh root@DEVICE "fdisk -l"
ssh root@DEVICE "dmesg | grep mmc"
```

**Common confusion:**
- `/dev/mmcblk0` = often SD card
- `/dev/mmcblk1` or `/dev/mmcblk2` = usually eMMC

**If you flashed the wrong device:**
- Don't panic
- If it was a backup/clone, reflash from your backup
- If it was the OS drive... hope you have backups

---

## Part V: Field Notes & Best Practices

### Before You Start

**Checklist:**
```
[ ] Verified SSH access to device
[ ] Confirmed eMMC device path (lsblk)
[ ] Checked eMMC size vs image size
[ ] Tested image integrity (zstd -t)
[ ] Ensured stable power supply
[ ] Backed up critical data (if any)
[ ] Informed users of downtime
[ ] Have recovery plan ready
```

---

### During Operation

**Monitor everything:**
```bash
# On device (if accessible)
watch -n1 'iostat -x 1 1 | grep mmcblk2'

# Network throughput
ssh root@DEVICE "nload eth0"

# Process status
ssh root@DEVICE "ps aux | grep dd"
```

**Don't:**
- Power cycle during flash
- Interrupt `dd` or `sync` commands
- Run multiple flash operations simultaneously
- Ignore error messages

---

### After Operation

**Verify the flash:**
```bash
# Check partitions exist
ssh root@DEVICE "fdisk -l /dev/mmcblk2"

# Check filesystems
ssh root@DEVICE "blkid"

# Test boot
ssh root@DEVICE "reboot"

# Verify services after boot
ssh root@DEVICE "systemctl status"
```

---

### Security Considerations

**You're running as root over SSH. Some things to think about:**

**Lock down SSH:**
```bash
# Generate SSH key if you haven't
ssh-keygen -t ed25519

# Copy to device
ssh-copy-id root@DEVICE

# Disable password auth
ssh root@DEVICE "
sed -i 's/PermitRootLogin yes/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config
systemctl restart sshd
"
```

**Use sudo instead of root:**
```bash
# Add user to sudoers
ssh admin@DEVICE "sudo usermod -aG sudo admin"

# Then run commands with sudo
ssh admin@DEVICE "sudo dd if=/dev/mmcblk2 bs=4M"
```

**Verify checksums:**
```bash
# Create checksum before compression
sha256sum original.img > original.img.sha256

# After decompression
zstd -dc image.img.zst | sha256sum
# Compare with original checksum
```

---

### Performance Tuning

**Block size matters:**

Test different block sizes to find optimal speed:
```bash
# 1MB
time sh -c "dd if=/dev/zero of=/tmp/test bs=1M count=1000 && sync"

# 4MB (usually good default)
time sh -c "dd if=/dev/zero of=/tmp/test bs=4M count=250 && sync"

# 16MB (may be faster on fast networks)
time sh -c "dd if=/dev/zero of=/tmp/test bs=16M count=63 && sync"
```

**SSH compression:**
```bash
# Enable SSH compression (may help on slow networks)
ssh -C root@DEVICE "dd if=/dev/mmcblk2 bs=4M" | zstd -T0 > backup.img.zst
```

**Direct I/O (bypass cache):**
```bash
# Use oflag=direct for immediate writes
zstd -dc image.wic.zst \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M oflag=direct status=progress && sync"
```

---

### Storage Calculations

**Quick math for time estimates:**

```
Network: 100 Mbps = ~12 MB/s actual throughput
eMMC write speed: ~50-150 MB/s (varies by chip)
Zstandard decompression: ~800 MB/s

Bottleneck is usually network.

7.3 GB image over 100 Mbps network:
7300 MB ÷ 12 MB/s ≈ 608 seconds ≈ 10 minutes

With 1.8 GB zstd compressed:
1800 MB ÷ 12 MB/s ≈ 150 seconds ≈ 2.5 minutes
```

**Real-world: Add 20-30% for overhead.**

---

### Creating Reusable Scripts

**Backup script:**
```bash
#!/bin/bash
# backup_emmc.sh

DEVICE_IP="${1:-192.168.1.100}"
BACKUP_DIR="${2:-./backups}"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

echo "Backing up device: $DEVICE_IP"
echo "Destination: $BACKUP_DIR"

# Full disk
echo "Pulling full disk image..."
ssh root@$DEVICE_IP "dd if=/dev/mmcblk2 bs=4M status=progress" \
  | zstd -T0 -19 > "$BACKUP_DIR/mmcblk2_$DATE.img.zst"

# Boot partitions
echo "Pulling boot partitions..."
ssh root@$DEVICE_IP "dd if=/dev/mmcblk2boot0 bs=1M" \
  > "$BACKUP_DIR/boot0_$DATE.img"
ssh root@$DEVICE_IP "dd if=/dev/mmcblk2boot1 bs=1M" \
  > "$BACKUP_DIR/boot1_$DATE.img"

# Generate checksums
cd "$BACKUP_DIR"
sha256sum mmcblk2_$DATE.img.zst boot0_$DATE.img boot1_$DATE.img \
  > checksums_$DATE.txt

echo "Backup complete: $BACKUP_DIR"
```

**Flash script:**
```bash
#!/bin/bash
# flash_emmc.sh

IMAGE="${1:?Usage: $0 <image.wic.zst> <device_ip>}"
DEVICE_IP="${2:?Usage: $0 <image.wic.zst> <device_ip>}"

echo "WARNING: This will ERASE $DEVICE_IP completely!"
echo "Image: $IMAGE"
read -p "Continue? (yes/no): " confirm

[[ "$confirm" != "yes" ]] && exit 1

# Verify image
echo "Verifying image integrity..."
zstd -t "$IMAGE" || exit 1

# Check device
echo "Checking device..."
ssh root@$DEVICE_IP "lsblk | grep mmcblk2" || exit 1

# Flash
echo "Flashing image..."
zstd -dc "$IMAGE" \
  | ssh root@$DEVICE_IP "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

echo "Rebooting device..."
ssh root@$DEVICE_IP "reboot"

echo "Flash complete. Wait 60s and verify."
```

---

## Part VI: Real-World Scenarios

### Scenario 1: Production Line Provisioning

**Situation:** You need to flash 100 identical devices in a factory.

**Approach:**
1. Create one golden image
2. Set up Ethernet switch with all devices connected
3. Assign sequential IPs (192.168.1.101-200)
4. Write a loop script:

```bash
#!/bin/bash
for ip in $(seq 101 200); do
  echo "Flashing 192.168.1.$ip"
  zstd -dc golden.wic.zst \
    | ssh root@192.168.1.$ip "dd of=/dev/mmcblk2 bs=4M && sync && reboot" &
done
wait
echo "All devices flashed"
```

**Optimization:** Flash in batches to avoid network saturation.

---

### Scenario 2: Field Device Replacement

**Situation:** Device failed in remote location. Tech on-site with replacement hardware.

**Approach:**
1. Tech connects replacement device to network
2. You flash it remotely from the office
3. Device is ready without shipping pre-programmed units

```bash
# From office
ssh tech@site-router "ssh root@192.168.1.50"
# Verify access
zstd -dc site_A_image.wic.zst \
  | ssh tech@site-router "ssh root@192.168.1.50 'dd of=/dev/mmcblk2 bs=4M && sync && reboot'"
```

---

### Scenario 3: Firmware Update Rollout

**Situation:** Update 20 devices in different locations with new firmware.

**Approach:**
1. Test new image on one device first
2. Create rollback plan (keep old image accessible)
3. Update in phases:

```bash
#!/bin/bash
# Phase 1: Test devices
for ip in 192.168.1.{101,102}; do
  echo "Updating test device $ip"
  ./flash_emmc.sh new_firmware_v2.wic.zst $ip
  sleep 300  # Wait 5 min, verify functionality
done

# Phase 2: If successful, roll out to production
for ip in 192.168.1.{103..120}; do
  echo "Updating production device $ip"
  ./flash_emmc.sh new_firmware_v2.wic.zst $ip
  sleep 60
done
```

---

### Scenario 4: Disaster Recovery

**Situation:** Device corrupted, won't boot. You have backups.

**Approach:**
1. Boot from SD card recovery image
2. Flash backup from your PC
3. Restore to working state

```bash
# Device boots from SD, eMMC is /dev/mmcblk2
zstd -dc backup_20260115.img.zst \
  | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

# Restore boot partitions
cat boot0_20260115.img \
  | ssh root@DEVICE "echo 0 > /sys/block/mmcblk2boot0/force_ro && dd of=/dev/mmcblk2boot0 bs=1M"

ssh root@DEVICE "reboot"
```

---

## Part VII: Knowledge Gaps & Gotchas

### Things That Aren't Obvious

**1. eMMC vs SD Card**
- eMMC is soldered to the board (permanent)
- SD card is removable
- Both show up as `mmcblk*` devices
- Check `dmesg | grep mmc` to identify which is which

**2. Boot partition write protection is sticky**
- Persists across reboots
- You must unlock every time
- Some platforms lock it in hardware (can't override)

**3. Live system flashing limitations**
- You CAN flash eMMC while system is running (dd works on live partitions)
- But it's risky if filesystem is being written to
- Better to boot from alternative media if possible

**4. Partition tables and bootloaders**
- WIC images include partition table
- Writing with `dd` overwrites EVERYTHING (including partition table)
- This is why it works, but also why you can't partially update

**5. Zstandard isn't always installed**
- Older embedded systems may not have it
- Fall back to gzip if needed
- Or build static binary and transfer it

**6. Network speed vs eMMC speed**
- Fast eMMC (150 MB/s) + slow network (12 MB/s) = network bottleneck
- Slow eMMC (30 MB/s) + fast network (100 MB/s) = eMMC bottleneck
- Match compression to bottleneck

---

### Common Mistakes

**Mistake:** Running `dd` without `sync`
```bash
# Wrong
dd of=/dev/mmcblk2 bs=4M

# Right
dd of=/dev/mmcblk2 bs=4M && sync
```

**Why:** Data may still be in buffers, not written to disk.

---

**Mistake:** Using wrong device identifier
```bash
# Easy to confuse
/dev/mmcblk0   # Could be SD card
/dev/mmcblk1   # Could be eMMC
/dev/mmcblk2   # Could be eMMC
```

**Always verify with:** `lsblk` and `dmesg | grep mmc`

---

**Mistake:** Forgetting to unlock boot partitions
```bash
# This will fail silently or error
dd of=/dev/mmcblk2boot0 bs=1M

# Must do this first
echo 0 > /sys/block/mmcblk2boot0/force_ro
```

---

**Mistake:** Not checking image size vs device size
```bash
# Image: 8 GB
# Device: 7.3 GB
# Result: Fails partway through, corrupted device
```

**Always check first:**
```bash
zstd -l image.wic.zst
ssh root@DEVICE "blockdev --getsize64 /dev/mmcblk2"
```

---

**Mistake:** Flashing incompatible images
- i.MX6 bootloader on Rockchip board = brick
- 32-bit image on 64-bit system = might boot, weird bugs
- Wrong kernel device tree = no peripherals work

**Know your hardware.**

---

### Platform-Specific Notes

**i.MX6 / i.MX8:**
- U-Boot typically at offset 1KB on eMMC
- Boot partition may contain SPL
- `dd seek=1` when flashing bootloader

**Rockchip (RK3399, RK3568, etc):**
- Bootloader in `mmcblk2boot0`
- May need `rkdeveloptool` for initial flash
- U-Boot in first few MB of main device

**Raspberry Pi Compute Module:**
- eMMC accessible via USB (special mode)
- Can use `rpiboot` and `dd` over USB
- No SSH needed initially

**BeagleBone:**
- eMMC vs SD card boot via boot pins
- Can flash eMMC from running SD card system
- `dd` works fine once booted

**NVIDIA Jetson:**
- Custom partition layout (many partitions)
- Use `flash.sh` script for full flash
- Partial updates via `dd` possible but tricky

---

## Part VIII: Final Thoughts

### What You've Learned

- How to pull complete disk images over network
- How to flash WIC/OS images remotely
- How to handle eMMC boot partitions
- How to use Zstandard for efficient compression
- How to recover from failed flashes
- How to automate deployment workflows

### What This Enables

- Remote device provisioning
- Disaster recovery without physical access
- Rapid deployment in production
- Field replacements with minimal downtime
- CI/CD integration for embedded systems

### What This Doesn't Replace

- Proper version control for your builds
- Automated testing before deployment
- Rollback mechanisms for failed updates
- Monitoring and alerting for device health
- Physical access when things go really wrong

---

### The Unwritten Rules

1. **Always have a backup.** Not metaphorically. Literally. Multiple backups.

2. **Test on non-critical hardware first.** Production is not the place to learn.

3. **Document your partition layouts.** Six months from now, you won't remember.

4. **Label your images properly.** "final_v2_actually_final.img.zst" is not a versioning strategy.

5. **Power loss during flash = bricked device.** Plan accordingly.

6. **Network drops are going to happen.** Use `screen`, `tmux`, or `nohup`.

7. **Not all eMMC is created equal.** Cheap chips fail. Buy from reputable vendors.

8. **U-Boot environment matters.** Wrong boot args = kernel panic even with good image.

9. **Serial console is your friend.** When SSH fails, UART saves you.

10. **Read the SoC reference manual.** Bootloader offset, partition layout—it's all in there.

---

### Tools You Should Have

**On your PC:**
```bash
sudo apt install -y \
  zstd \
  pv \
  openssh-client \
  screen \
  tmux \
  usbutils \
  minicom
```

**On your devices (if possible):**
```bash
opkg install zstd screen  # OpenWrt
apt install zstd screen   # Debian/Ubuntu
```

**In your toolkit:**
- UART/serial cable (FTDI, CP2102, whatever works)
- SD card with recovery image
- Backup power (UPS or battery pack)
- Network switch (for multi-device ops)
- Documentation for your hardware platform

---

### When to Use This vs Other Methods

**Use SSH/dd when:**
- Device is network-accessible
- You have root SSH access
- Device has enough RAM for dd operations
- Network bandwidth is reasonable

**Use vendor tools when:**
- Initial provisioning (blank eMMC)
- Device is bricked (won't boot to OS)
- Hardware recovery mode is available
- Vendor tools provide additional verification

**Use physical access when:**
- SSH is impossible to set up
- eMMC needs to be replaced anyway
- Device is security-locked
- All remote options have failed

---

### Resources

**Zstandard:**
- https://github.com/facebook/zstd
- https://facebook.github.io/zstd/

**dd documentation:**
- `man dd`
- https://www.gnu.org/software/coreutils/manual/html_node/dd-invocation.html

**eMMC specifications:**
- JEDEC Standard No. 84-B51
- https://www.jedec.org/standards-documents/docs/jesd84-b51

**Platform-specific guides:**
- Check your SoC vendor's developer wiki
- Board manufacturer documentation
- Community forums (BeagleBoard.org, Armbian, etc.)

---

### This Guide

Written for people who need to get things done. No corporate sanitization. No dumbed-down explanations. Just the technical details you need to flash embedded Linux devices over the network without screwing it up.

Keep it handy. You'll need it again.

---

**— Kalpesh**  
*Embedded Linux / eMMC / SSH Deployment*  
*January 2026*

---

## Appendix: Quick Reference

```bash
# Clone device A → PC
ssh root@DEVICE_A "dd if=/dev/mmcblk2 bs=4M" | zstd -T0 -19 > backup.img.zst

# Restore PC → device B
zstd -dc backup.img.zst | ssh root@DEVICE_B "dd of=/dev/mmcblk2 bs=4M && sync"

# Flash WIC image
zstd -dc image.wic.zst | ssh root@DEVICE "dd of=/dev/mmcblk2 bs=4M status=progress && sync"

# Unlock boot partitions
ssh root@DEVICE "echo 0 > /sys/block/mmcblk2boot0/force_ro"

# Flash boot partition
cat boot0.img | ssh root@DEVICE "dd of=/dev/mmcblk2boot0 bs=1M && sync"

# Lock boot partitions
ssh root@DEVICE "echo 1 > /sys/block/mmcblk2boot0/force_ro"

# Verify device
ssh root@DEVICE "lsblk && fdisk -l /dev/mmcblk2"

# Reboot
ssh root@DEVICE "reboot"
```

**If you are here then it is Done**
